continue
columns_joined
continue
group.cache_key_with_version
continue
params["group_id"]
params
param
continue
Group.last.id
Group.last.destroy
Group.last.destry
Group.last.id
Group.where(parent_id: nil)
Group.where(parent_i: nil)
Group.create(id: 99999999, parent_id: 1)
Group.first(20)
Group.create
Group.new(parent_id: root.id).save!
Group.new(parent_id: root.id)
root.id
root
Group.create(parent_id: root.id, name: "Root G")
continue
ch
continue
params[:id]
id
params
continue
tree = Node.new(**root_group.symbolize_keys!)
tree = Node.new(root_group.symbolize_keys!)
continue
root_group.symbolize_keys!
root_group
continue
tree = Node.new(root_group)
root_group
continue
root_group.values_at(:id, :parent_id, :name, "lvl")
root_group
id
continue
Node.new(1,3,4,5 )
Node.new(id: 1)
tree
continue
Node.new(find_root_group(groups, root_id))
Node.new(find_root_group(groups, root_id)))
Node.new(find_root_group(groups, root_id).merge(children: []))
Node.new(**find_root_group(groups, root_id).merge(children: []))
find_root_group(groups, root_id).merge(children: [])
root_group
tree = Node.new(**root_group)
tree = Node.new(root_group)
continue
groups.count
groups
continue
tree[:children] = grouped_groups[tree["id"]].map(&:attributes)
continue
grouped_groups[tree["id"]].each(&:attributes)
grouped_groups[tree["id"]].each(:&attributes)
grouped_groups[tree["id"]].first
grouped_groups[tree["id"]]
continue
child
child[:children] = []
child[:children]
child[:children] = [grouped_groups[child["id"]]]
 child[:children].nil?
continue
child
continue
child
continue
grouped_groups[tree["id"]]
continue
tree[:children].first
tree[:children]
continue
tree["id"]
tree[:id]
tree
tree.id
grouped_groups
tree
continue
 groups.reject { |group| group.id != root_id }
continue
root_id.to_i
groups.first.id
groups.first
groups.firs
root_id
rooy_id
groups
 groups.reject { |group| group.id != root_id }
continue
groups.group_by(&:parent_id)
groups.group_by(:parent_id)
continue
name
parent_id
continue
tree[id]
parent_id
tree[parent_id][:children]
continue
tree[parent_id][:children].push(tree[id])
continue
tree[parent_id][:children].push(tree[id])
continue
tree
tree[parent_id][:children].push(tree[id])
tree[id]
tree[parent_id][:children]
continue
tree_1
continue
tree_1
tree
continue
tree_1
tree[:id]
continue
tree[:id]
tree[:id] == tree_1[:parent_id]
continue
tree[:children].push(tree_1)
tree[:children]
tree[:children] = []
tree[:children]
tree
tree[:children]
continue
tree[:id] == tree_1[:parent_id]
tree[:id] == tree[:parent_id]
tree_1
tree
continue
tree
continue
parent_id
id
continue
tree
 groups
continue
tree.keys
tree
tree[parent_id][:children].push(tree_1[id])
tree[parent_id]
tree_1
continue
tree
tree[id][:id] = id
tree[id][:id]
tree
continue
n
n.
n.values
id
n
id
tree[id]
tree
continue
tree
continue
tree
continue
tree
continue
groups[1..-1].count
groups[1..-1]
tree
continue
tree.keys
tree
continue
tree
tree.keys
continue
tree.keys
continue
tree.keys
tree
continue
tree
continue
tree[id]
tree[parent_id][:children]
tree
continue
tree[:children]
tree
continue
tree
parent_id
id
name
parent_id
tree
continue
tree
continue
tree[parent_id][:children].push(tree[id])
tree[id][:level] = lvl
tree[id][:parent_id] = parent_id
tree[id][:name] = name
id
tree[id][:name]
name
continue
tree[:dupa]
tree = Hash.new { |h,k| h[k] = { :name => nil, :children => [ ] } }
hi.default_proc
hi.default_proc.call
hi = Hash.new { |hash, key| "Default value for #{key} hash: #{hash}" }
hi.default_proc.call
hi = Hash.new { |hash, key| "Default value for #{key}" }
h
h = Hash.new { |hash, key| "Default value for #{key}" }
tree
tree = Hash.new { |h,k| puts h puts "dupa" }
tree = Hash.new { |h,k| puts h puts k }
tree = Hash.new { |h,k| puts h; puts k; }
tree = Hash.new { |h,k| puts h; puts k; h[k] = { :name => first_node.name, :children => [ ] } }
continue
Group.find(params[:group_id]).all_children_sql.count
continue
groups.count
grouds.count
continue
tree
continue
Hash.new(first_node.attributes.merge(children: []))
first_node.attributes.merge(children: [])
tree
continue
arr
arr.each do |n|
  id, parent_id = n.values_at(:id, :parent_id)
  tree[id][:name] = n[:name]
  tree[parent_id][:children].push(tree[id])
end
tree = Hash.new { |h,k| h[k] = { :name => nil, :children => [ ] } }
arr = groups
groups.where(parent_id: first_node.id)
first_node
continue
groups.first.children
groups.first
groups
